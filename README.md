# java-multi-thread-demo
---

本程序(节能灯控制系统)设计使用了**观察者模式**

## 线程的五种状态
* 新建状态：创建线程对象
* 待运行：线程调用start（）之后，有执行的资格，没有执行权。
* 运行：获得cpu的执行权（当加锁保证线程安全时会进入锁池等待获取锁，即同步阻塞）
* 阻塞： 
  * 等待阻塞：Object的wait（）方法调用后， 进入等待队列，唤醒后进入锁池，获得锁后又回到待运行状态。
  * 同步阻塞：争抢cpu使用权，没抢到手，进入锁池等待获得锁。
  * 其他阻塞：如sleep（），join（），时间结束后进入待运行状态。
* 死亡：run，main执行结束，或因异常退出。
* 线程终止的两大原因：当线程的run方法执行方法体中最后一条语句后，并经由return语句返回时，或者出现没有捕获的异常时，线程将终止。


## 线程创建的三种基本方式
* 继承Thread类，重写run方法，自定义类的实例，调用start（）方法启动线程
* 实现Runnable接口，重写run方法，自定义类的实例，调用start（）方法启动线程
* 采用Excutor创建线程池
  * newCachedThreadPool 创建一个**可缓存线程池**，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。
  * newFixedThreadPool 创建一个**定长线程池**，可控制线程最大并发数，超出的线程会在队列中等待。
  * newScheduledThreadPool 创建**一个定长线程池**，支持定时及周期性任务执行。cheduledExecutorService比Timer更安全，功能更强大     
  * newSingleThreadExecutor 创建**一个单线程化的线程池**，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

## 三种方式的比较
a.单继承的局限
b.更好的体现面向对象的分离（线程与程序的分离）
c.适合多个程序去处理同一资源的情况

## 线程池与new Thread的比较
new Thread的弊端：
* 每次 new Thread新建对象性能差
* 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能过多的占用系统资源导致死机。
* 缺乏更多功能，如定时执行，定期执行，线程中断。
线程池的优势：
* 重用存在的线程，减少对象创建、消亡的开销，性能佳。
* 可有效控制最大并发线程数，提高系统资源的使用率，减少过多资源竞争，避免阻塞。
* 提供定时执行、定期执行、单线程、并发数控制等功能。


